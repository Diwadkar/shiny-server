#detach("package:Gviz", unload=TRUE) # this is to keep RStudio happy - run if loading app more than once in same session - keep commented out otherwise
# if load Gviz 2x in same session (i.e. close & re-run app), get "object of type 'closure' is not subsettable" error
# should not be an issue when running app from the website
# cat(file=stderr(), as.character(Sys.time()),"packages start\n")
# use this type of command to easily see dataset loading time in RStudio  
# currently 3 seconds from "start package load" to "finish gene_locations load"
#rlang version 0.2.1

.libPaths("/home/maya/R/x86_64-pc-linux-gnu-library/3.4/")
library(Gviz)
#source("/srv/shiny-server/realgar/global.R")

# server
server <- shinyServer(function(input, output, session) {
  
  all_genes <- unique(all_genes)
  genes <- reactive({selectizeInput("current", "Official Gene Symbol or SNP ID:", all_genes, selected="GAPDH", width="185px", options = list(create = TRUE))})
  output$genesAvail <- renderUI({genes()})
  
  output$loadProxy <- renderUI({NULL})
  
  current <- reactive({toString(input$current)})
  curr_gene <- reactive({
    if (gsub(" ", "", tolower(current()), fixed=TRUE) %in% c(snp$snp, snp_eve$snp, snp_gabriel$snp, snp_fer$snp, snp_TAGC$snp)) { #if SNP ID is entered, convert internally to nearest gene symbol  
      all_matches <- rbind(rbind(snp[which(snp$snp==gsub(" ", "", tolower(current()), fixed=TRUE)), c("snp", "end", "symbol")], 
                                 snp_eve[which(snp_eve$snp==gsub(" ", "", tolower(current()), fixed=TRUE)), c("snp", "end", "symbol")]), 
                           snp_gabriel[which(snp_gabriel$snp==gsub(" ", "", tolower(current()), fixed=TRUE)), c("snp", "end", "symbol")],
                           snp_fer[which(snp_fer$snp==gsub(" ", "", tolower(current()), fixed=TRUE)), c("snp", "end", "symbol")],
                           snp_TAGC[which(snp_TAGC$snp==gsub(" ", "", tolower(current()), fixed=TRUE)), c("snp", "end", "symbol")])
      gene_locations_unique <- gene_locations[which(!duplicated(gene_locations$symbol)),]
      all_matches <- merge(all_matches, gene_locations_unique[,c("symbol", "start")], by="symbol")
      print(all_matches)
      all_matches$dist <- abs(all_matches$start - all_matches$end) # here, "end" is snp position, "start" is gene start 
      unique(all_matches$symbol[which(all_matches$dist==min(all_matches$dist))]) # choose the gene symbol whose start is the smallest absolute distance away
    } else { 
      # if it is not in the list of snps, it is a gene id OR a snp that is not associated with asthma
      # in the latter case it will not show up in the list of genes & user gets an "enter valid gene/snp id" message
      gsub(" ", "", toupper(current()), fixed = TRUE) #make uppercase, remove spaces
    }
  })  

  
  GeneSymbol <- reactive({if (curr_gene() %in% genes_avail) {TRUE} else {FALSE}})  #used later to generate error message when a wrong gene symbol is input
  
  ################################################
  ## reactive UI for EVE & TAGC p-value options ##
  ################################################
  
  #if either EVE or TAGC SNPs selected, display the phrase "GWAS display options:"
  output$GWAS_text <- reactive({if("snp_eve_subs" %in% input$which_SNPs | "snp_TAGC_subs" %in% input$which_SNPs){"GWAS display options:"} else {""}})
  
  #if EVE SNPs selected, display option to choose population
  output$eve_options <- reactive({if("snp_eve_subs" %in% input$which_SNPs) {"-----------------------------------"} else {""}})
  
  #if TAGC SNPs selected, display option to choose population
  output$TAGC_options <- reactive({if("snp_TAGC_subs" %in% input$which_SNPs) {"-----------------------------------"} else {""}})
  
    
  #################################################################################
  ## "Select all" buttons for tissue, asthma, treatment and GWAS study selection ##
  #################################################################################
  
  #Tissue
  observe({
    if(input$selectall_tissue == 0) return(NULL) # don't do anything if action button has been clicked 0 times
    else if (input$selectall_tissue%%2 == 0) { # %% means "modulus" - i.e. here you're testing if button has been clicked a multiple of 2 times
      updateCheckboxGroupInput(session,"Tissue","Tissue:",choices=tissue_choices, selected = tissue_choices)
      updateActionButton(session, "selectall_tissue", label="Unselect all") # change action button label based on user input
    } else { # else is 1, 3, 5 etc.
      updateCheckboxGroupInput(session,"Tissue","Tissue:",choices=tissue_choices)
      updateActionButton(session, "selectall_tissue", label="Select all")
    }
  })
  
  #Disease
  
  observe({
    if(input$selectall_asthma == 0) return(NULL) 
    else if (input$selectall_asthma%%2 == 0) {
      updateCheckboxGroupInput(session,"Asthma",label="Condition vs Healthy:", choices=asthma_choices, selected = asthma_choices)
      updateActionButton(session, "selectall_asthma", label="Unselect all")
    }
    else {
      updateCheckboxGroupInput(session, "Asthma", label="Condition vs Healthy:", choices=asthma_choices)
      updateActionButton(session, "selectall_asthma", label="Select all")
    }})
  
  
  #Treatment
  observe({
      if(input$selectall_treatment == 0) return(NULL) 
      else if (input$selectall_treatment%%2 == 0) {
        updateCheckboxGroupInput(session, "Treatment", "Treatment:", choices = treatment_choices, selected = treatment_choices)
        updateActionButton(session, "selectall_treatment", label="Unselect all")
      }
      else {
          updateCheckboxGroupInput(session, "Treatment", "Treatment:", choices = treatment_choices)
          updateActionButton(session, "selectall_treatment", label="Select all")
      }})
  
  #GWAS
  observe({
      if(input$selectall_GWAS == 0) return(NULL) 
      else if (input$selectall_GWAS%%2 == 0) {
          updateCheckboxGroupInput(session,"which_SNPs","GWAS Results",choices=gwas_choices)
          updateActionButton(session, "selectall_GWAS", label="Select all")
      }
      else {
          updateCheckboxGroupInput(session,"which_SNPs","GWAS Results", choices=gwas_choices, selected=gwas_choices)
          updateActionButton(session, "selectall_GWAS", label="Unselect all")
      }})
  
    
  #######################
  ## GEO studies table ##
  #######################
  #select GEO studies matching desired conditions;
  #Jessica's initial app had an "and" condition here; Maya changed it to "or"
  # Mengyuan changed it to: if only select tissue or asthma/treatment, will use all the available studies; else use the intersection
  UserDataset_Info <- reactive({
    #Dataset_Info1 = subset(Dataset_Info,(((Dataset_Info$Tissue %in% input$Tissue) | (Dataset_Info$Asthma %in% input$Asthma)) & Dataset_Info$App == "asthma")) 
    #Dataset_Info2 = subset(Dataset_Info,(((Dataset_Info$Tissue %in% input$Tissue) | (Dataset_Info$Asthma %in% input$Treatment)) & Dataset_Info$App == "GC")) 
    ## Dataset_Info2 = subset(Dataset_Info, (((Dataset_Info$Tissue %in% input$Tissue) & ((Dataset_Info$Asthma %in% input$Treatment) | (Dataset_Info$App %in% input$Treatment)))))
    #Dataset_Info = rbind(Dataset_Info1, Dataset_Info2) # this separates GC and asthma data
    Dataset_Info_Tissue = subset(Dataset_Info, Dataset_Info$Tissue %in% input$Tissue)
    
    #To avoid selection of all tissues on getting an empty dataframe inspite of non-null selections
    if(is.null(input$Asthma)| is.null(input$Status)){Dataset_Info_A = subset(Dataset_Info, Dataset_Info$Asthma %in% input$Asthma | Dataset_Info$Status %in% input$Status)}
    else {Dataset_Info_A = subset(Dataset_Info, Dataset_Info$Asthma %in% input$Asthma & Dataset_Info$Status %in% input$Status)}
    if(is.null(input$Treatment)| is.null(input$Experiment)){Dataset_Info_B = subset(Dataset_Info, Dataset_Info$Asthma %in% input$Treatment | Dataset_Info$Experiment %in% input$Experiment)}
    else {Dataset_Info_B = subset(Dataset_Info, Dataset_Info$Asthma %in% input$Treatment & Dataset_Info$Experiment %in% input$Experiment)}
    
    Dataset_Info_Asthma = rbind(Dataset_Info_A,Dataset_Info_B)
    
    if ((nrow(Dataset_Info_Tissue)==0)|(nrow(Dataset_Info_Asthma)==0)) {Dataset_Info1=rbind(Dataset_Info_Tissue,Dataset_Info_Asthma)}
    else {Dataset_Info1=subset(Dataset_Info_Tissue,Dataset_Info_Tissue$Unique_ID%in%Dataset_Info_Asthma$Unique_ID)}
    
    #BA_PDE
    if(length(setdiff(c("BA","PDE"),input$Treatment))==0 && "invitro" %in% Dataset_Info1$Experiment){Dataset_Info1 = rbind(Dataset_Info1,BA_PDE_Info)}
    
    #Return
    Dataset_Info1
    
  }) %>% debounce(1000)
  
  # gene expression (GEO) studies table
  #add links for GEO_ID and PMID
  GEO_data <- reactive({
      validate(need(nrow(UserDataset_Info()) != 0, "No gene expression datasets selected")) #Generate a error message when no data is loaded.
      
      UserDataset_Info() %>%
          dplyr::mutate(GEO_ID_link = ifelse(grepl("SRP", GEO_ID), #GEO link is conditional on whether GEO_ID is an "SRP" or "GSE"
                                             paste0("http://www.ncbi.nlm.nih.gov/sra/?term=", GEO_ID), 
                                             paste0("https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=", GEO_ID)),
                        PMID_link = paste0("http://www.ncbi.nlm.nih.gov/pubmed/?term=", PMID),
                        QC_link = ifelse(grepl("SRP", GEO_ID), #QC link is conditional on whether GEO_ID is an "SRP" or "GSE"
                               paste0("http://public.himeslab.org/realgar_qc/",GEO_ID,"_QC_RnaSeqReport.html"), 
                               paste0("http://public.himeslab.org/realgar_qc/",GEO_ID,"_QC_report.html")))})
  
  
  
  GEO_Dataset <- reactive({paste0("<a href='",  GEO_data()$GEO_ID_link, "' target='_blank'>",GEO_data()$GEO_ID,"</a>")})
  GEO_PMID <- reactive({paste0("<a href='",  GEO_data()$PMID_link, "' target='_blank'>",GEO_data()$PMID,"</a>")})
  GEO_Description <- reactive({GEO_data()$Description})
  GEO_Report <- reactive({paste0("<a href='",  GEO_data()$QC_link, "' target='_blank'>",GEO_data()$Report,"</a>")})
  
  
  GEO_links <- reactive({
      df <- data.frame(GEO_Dataset(), GEO_PMID(),GEO_Report(), GEO_Description())
      colnames(df) <- c("Dataset", "PMID", "Report","Description")
      df
  })
  
  # gwas studies table

  GWAS_data <- reactive({
    df <- GWAS_Dataset_Info[which(GWAS_Dataset_Info$Tissue %in% input$which_SNPs),c("GEO_ID", "PMID","Description")]
    validate(need(nrow(df) != 0, "No GWAS datasets selected")) #Generate a error message when no data is loaded.
    colnames(df) <- c("Dataset", "Link","Description") # I put the link for the study into the PMID column of the spreadsheet for convenience - change later?
    df
  })
  
  GWAS_Dataset <- reactive({paste0("<a href='",  GWAS_data()$Link, "' target='_blank'>",GWAS_data()$Dataset,"</a>")})
  GWAS_Description <- reactive({GWAS_data()$Description})
  
  GWAS_links <- reactive ({
    df <- data.frame(GWAS_Dataset(), GWAS_Description())
    colnames(df) <- c("Dataset", "Description")
    df
  })
  
  
  #table output for "Datasets Loaded" tab
  output$GEO_table <- DT::renderDataTable(GEO_links(),  
                                          class = 'cell-border stripe', 
                                          rownames = FALSE, 
                                          options = list(paging = FALSE, searching = FALSE),
                                          escape = FALSE)
  
  output$GWAS_table <- DT::renderDataTable(GWAS_links(),
                                           class = 'cell-border stripe',
                                           rownames = FALSE,
                                           options = list(paging = FALSE, searching = FALSE), 
                                           escape = FALSE)
  
  #########################################
  ## Select GEO data for plots and table ##
  #########################################
  
  #select and modify data used for plots and accompanying table
  output.tableforplot <- reactive({
      validate(need(nrow(UserDataset_Info()) != 0, "Please choose at least one dataset.")) #Generate a error message when no data is loaded.
      validate(need(curr_gene() != "", "Please enter a gene symbol or SNP ID.")) #Generate a error message when no gene id is input.
      
      #select data for the gene currently selected
      data_filter <- function(x){
        x <- x %>%
          dplyr::filter(Gene==curr_gene()) %>%
          dplyr::select(logFC, P.Value, adj.P.Val, SD, rank) %>% 
          dplyr::filter(P.Value==min(P.Value)) %>%
          dplyr::mutate(lower = logFC - 2*SD, upper = logFC + 2*SD)
      }
      
      #get data for given gene for each study selected
      for (i in UserDataset_Info()$Unique_ID){
          curr.gene.data=get(i,environment())
          Total = UserDataset_Info() %>% dplyr::filter(Unique_ID == i) %>% select(Total) # This 'Total' is total sample size and can be used to combine p-values
          data_type = UserDataset_Info() %>% dplyr::filter(Unique_ID == i) %>% select(App) #This 'data_type' can be used to separate asthma and GC data. 

          #use data_filter function from above to filter curr.gene.data
          if (any(GeneSymbol())) {
              
              curr.gene.data <- data_filter(curr.gene.data)
              
              if(nrow(curr.gene.data) > 0) {
                  curr.gene.data <- curr.gene.data[order(curr.gene.data$P.Value,-abs(curr.gene.data$logFC)),][1,] # if multiple probes have the same smallest p-values, select the one with largest effect
                  curr.gene.data <- cbind(data_type, Unique_ID=i, curr.gene.data, Total)
                  #append curr.gene.data to all the other data that needs to be included in the levelplots
                  output.table <- rbind(output.table, curr.gene.data)}}}
      
      #preparing the data for levelplots
      #calculate the fold change, order by fold change for levelplots
      validate(need(GeneSymbol() != FALSE, "Please enter a valid gene symbol or SNP ID.")) # Generate error message if the gene symbol is not right.
      
      output.table <- dplyr::mutate(output.table, Fold_Change=2^(logFC), 
                                    neglogofP=(-log10(adj.P.Val)), #note that this is taking -log10 of adjusted p-value
                                    Lower_bound_CI = 2^(lower), 
                                    Upper_bound_CI = 2^(upper)) 
      
      output.table <- output.table[order(output.table$Fold_Change, output.table$Upper_bound_CI),]
     
  })
  
  
  ###################################
  ## Data table for meta-analysis  ##
  ###################################
  
  # asthma
  data_Asthma <- reactive({ 
  output.tableforplot_asthma = output.tableforplot() 
  output.tableforplot_asthma = output.tableforplot_asthma[output.tableforplot_asthma$App == "asthma",]
  output.tableforplot_asthma[rev(rownames(output.tableforplot_asthma)),]})
  
  # GC
  data_GC <- reactive({ 
  output.tableforplot_GC = output.tableforplot()
  output.tableforplot_GC = output.tableforplot_GC[output.tableforplot_GC$App %in% c("GC", "BA", "smoking", "vitD","PDE"),]
  output.tableforplot_GC[rev(rownames(output.tableforplot_GC)),]})
  
  
  ###################################
  ##        Combined p-values      ##
  ###################################
  
  # asthma
  asthma_pcomb <- reactive({
    dat <- data_Asthma()
    if (length(dat$adj.P.Val)>1) {
      #write.table(dat,paste0("Asthma_",curr_gene(),".txt"),col.names=T,row.names=F,sep="\t",quote=F)
      asthma_rankprod_pcomb <- rankprod_stat(dat)
      asthma_sumlog_pcomb <- sumlog_stat(dat)
      pcomb_text=paste0("P-value-based integration = ", asthma_sumlog_pcomb, "; Rank-based integration = ", asthma_rankprod_pcomb)
    }
    else {pcomb_text=""}
    pcomb_text
  })
  
  output$asthma_pcomb_text <- renderText({asthma_pcomb()})
  
  # GC
  GC_pcomb <- reactive({
    dat <- data_GC()
    if (length(dat$adj.P.Val)>1) {
      #write.table(dat,paste0("GC_",curr_gene(),".txt"),col.names=T,row.names=F,sep="\t",quote=F)
      GC_rankprod_pcomb <- rankprod_stat(dat)
      GC_sumlog_pcomb <- sumlog_stat(dat)
      pcomb_text=paste0("P-value-based integration = ", GC_sumlog_pcomb, "; Rank-based integration = ", GC_rankprod_pcomb)
    }
    else {pcomb_text=""}
    pcomb_text
  })
  
  output$GC_pcomb_text <- renderText({GC_pcomb()})
  
  ###################################
  ##          Meta-analysis        ##
  ###################################
  
  # p-values, effect size and 95% CI will be used for forestplot
  # asthma
  meta_Asthma <- reactive({
      dat <- data_Asthma()
      if (length(dat$adj.P.Val)>1) {
          res <- meta_stat(dat)
      }
      else {res <- list(meta_pval=1,meta_fc=1,meta_lower=1,meta_upper=1)} # assign any values to trick the app if no "treatment" is selected
      res
  })  
  
  meta_GC <- reactive({
      dat <- data_GC()
      if (length(dat$adj.P.Val)>1) {
          res <- meta_stat(dat)
      }
      else {res <- list(meta_pval=NA,meta_fc=NA,meta_lower=NA,meta_upper=NA)}
      res
  })  
  
  ###################################
  ## Data table accompanying plots ##
  ###################################
  
  # asthma
  
  data2_Asthma <- reactive({ # dataset without meta-analysis results
      data_Asthma()%>%
          dplyr::select(Unique_ID, adj.P.Val, P.Value,Fold_Change, neglogofP, Lower_bound_CI, Upper_bound_CI) %>%
          arrange(desc(Fold_Change),desc(Upper_bound_CI)) %>% # sort by first effect size (fold change) and then by upper CI in a descending order
          dplyr::mutate(Fold_Change=round(Fold_Change,digits=2),
                        adj.P.Val=format(adj.P.Val, scientific=TRUE, digits=3), 
                        P.Value =format(P.Value, scientific=TRUE, digits=3), 
                        Lower_bound_CI = round(Lower_bound_CI, digits = 2), 
                        Upper_bound_CI = round(Upper_bound_CI, digits = 2), 
                        Comparison = "Asthma vs. non-asthma")%>%
          dplyr::rename(`Study ID`=Unique_ID, `P Value`=P.Value, `Q Value`=adj.P.Val, `Fold Change`=Fold_Change)})
  
  # Function: "interdata_func"
  # obtain intermediate data with meta-analysis results added for table output and forest plots
  interdata_func <- function(dat,meta_dat){
      if (nrow(dat)==0) {return(data.frame())} # define an empty dataset if nothing is selected
      # add meta-analysis results if more than one study were observed
      if (nrow(dat)>1) {
          meta_pval=format(meta_dat[["meta_pval"]],scientific=TRUE, digits=3)
          meta_fc=round(meta_dat[["meta_fc"]],2)
          meta_lower=round(meta_dat[["meta_lower"]],2)
          meta_upper=round(meta_dat[["meta_upper"]],2)
          meta_neglogofP=-log10(meta_dat[["meta_pval"]])
          
          dat <- rbind(dat,rep(NA,ncol(dat)))
          dat$`Q Value`[nrow(dat)] <- meta_pval
          dat$`Fold Change`[nrow(dat)] <- meta_fc
          dat$Lower_bound_CI[nrow(dat)] <- meta_lower
          dat$Upper_bound_CI[nrow(dat)] <- meta_upper
          dat$neglogofP[nrow(dat)] <- meta_neglogofP
      }
      
      # merge information from info sheet
      text_temp <- merge(dat, as.matrix(Dataset_Info[which(Dataset_Info$Unique_ID %in% dat$`Study ID`),]), by.x="Study ID", by.y="Unique_ID", all.x=T)
      
      # sort by effect size (fold change) by individual study as the order changes after merging
      if (nrow(text_temp)>1) {
          meta_row <- text_temp[nrow(text_temp),]
          study_row <- text_temp[1:(nrow(text_temp)-1),] # sort exclude the meta-analysis result
          study_row <- study_row[order(-study_row$`Fold Change`, -study_row$Upper_bound_CI),]
          text_temp <- rbind(study_row,meta_row)
      }
      # select columns used for table output and forest plots
      text_temp <- text_temp[,c(names(dat),"GEO_ID","Asthma","Treatment","Long_tissue_name","Total","App")] # include total sample size
      # modify asthma endotypes or treatment conditions
      text_temp[,"Asthma"] <- gsub("_", " ", text_temp[,"Asthma"])
      text_temp[,"Treatment"] <- gsub("_", " ", text_temp[,"Treatment"])
      # compute total sample size for meta-analysis results
      text_temp[,"Total"] <- as.character(text_temp[,"Total"])
      text_temp[nrow(text_temp),"Total"] <- sum(as.numeric(text_temp[-nrow(text_temp),"Total"]))
      return(text_temp)
  }
  
  # Function: "tableforgraph_func" 
  # Obtain table output
  tableforgraph_func <- function(dat){
      empt_dat <- data.frame(matrix(ncol=6, nrow = 0)) # create an empty dataset if nothing is selected
      names(empt_dat) <- c("Study ID", "Tissue", "Comparison", "P Value", "Q Value", "Fold Change(95% CI)")
      if (nrow(dat)==0) {return(empt_dat)}
      data4table <- dat %>% 
          dplyr::mutate(`Study ID`=GEO_ID, `Tissue`=Long_tissue_name, `Fold Change(95% CI)` = paste(`Fold Change`, " ","(", Lower_bound_CI, ",", Upper_bound_CI, ")", sep = "")) %>%
          dplyr::select(`Study ID`, `Tissue`, `Comparison`, `P Value`, `Q Value`, `Fold Change(95% CI)`) %>%
          mutate_all(as.character)
      if (nrow(data4table)>1) {
          data4table[nrow(data4table),c("Study ID")] <- "Combined"
          data4table[nrow(data4table),c("Comparison")] <- data4table[1,c("Comparison")]
      }
      return(data4table)
  }
  
  # obtain intermediate asthma data for table output and forest plots
  data3_Asthma <- reactive({
    interdata_func(data2_Asthma(),meta_Asthma())
  }) 
  
  # output table for asthma
  tableforgraph_Asthma <- reactive({
      tableforgraph_func(data3_Asthma())
  })
  
  # GC
  data2_GC <- reactive({
      data_GC()%>%
          dplyr::select(Unique_ID, adj.P.Val, P.Value,Fold_Change, neglogofP, Lower_bound_CI, Upper_bound_CI) %>%
          dplyr::mutate(Fold_Change=round(Fold_Change,digits=2),adj.P.Val=format(adj.P.Val, scientific=TRUE, digits=3), P.Value =format(P.Value, scientific=TRUE, digits=3), 
                        Lower_bound_CI = round(Lower_bound_CI, digits = 2), Upper_bound_CI = round(Upper_bound_CI, digits = 2), Comparison = "Stimulation vs. at baseline")%>%
          dplyr::rename(`Study ID`=Unique_ID, `P Value`=P.Value, `Q Value`=adj.P.Val, `Fold Change`=Fold_Change)})
  
  # obtain intermediate GC data for table output and forest plots
  data3_GC <- reactive({
    interdata_func(data2_GC(),meta_GC())
  }) 
  
  # output table for GC
  tableforgraph_GC <- reactive({
      tableforgraph_func(data3_GC())
  })
  
  
  #combine asthma & GC into one
  output$tableforgraph <- DT::renderDataTable(rbind(tableforgraph_Asthma(), tableforgraph_GC()),
                                              class = 'cell-border stripe', 
                                              rownames = FALSE, 
                                              options = list(paging = FALSE, searching = FALSE),
                                              width = "100%")
  
  ################################################
  ## reactive UI for forestplot download options ##
  ################################################
  
  #if EVE SNPs selected, display option to choose population
  #output$asthma_fp_download <- renderUI({if(nrow(data3_Asthma())!= 0) {downloadButton(outputId="asthma_fc_download",label="Download asthma forest plot")} else {NULL}})
  
  #if TAGC SNPs selected, display option to choose population
  #output$GC_fp <- reactive({if(nrow(data3_GC())!= 0) {" "} else {NULL}})
  
  
  #################
  ## Forestplots ##
  #################
  
  # asthma forestplot
  
  getHeightAsthma <- reactive({
    getHeight_func(data3_Asthma())
  })
  
  forestplot_asthma <- reactive({
    forestplot_func(data3_Asthma(),"Asthma Transcriptomic Results for ",curr_gene())
  }) 
  
  # GC forestplot
  
  getHeightGC <- reactive({
    getHeight_func(data3_GC())
  })
  
  forestplot_GC <- reactive({
    forestplot_func(data3_GC(),"Exposure Transcriptomic Results for ",curr_gene())
  }) 
  
  output$forestplot_asthma = renderPlot({forestplot_asthma()}, height=getHeightAsthma)
  
  output$forestplot_GC = renderPlot({forestplot_GC()}, height=getHeightGC)
  
  ###############################
  ## Gene, SNP and TFBS tracks ##
  ###############################
  
  #horizontal color scale for gene tracks
  output$color_scale3 <- renderImage({ 
    return(list(
      src = "/srv/shiny-server/databases/www/color_scale_horizontal.png",
      height=109*1.05,
      width=1015*1.05,
      filetype = "image/png",
      alt = "color_scale"))}, deleteFile = FALSE)
  
  #filter data for selected gene
  gene_subs <- reactive({
    gene_subs_temp <- unique(filter(gene_locations, symbol==curr_gene()))
    gene_subs_temp <- gene_subs_temp[!(duplicated(gene_subs_temp$exon)),]})
  tfbs_subs <- reactive({unique(filter(tfbs, symbol==curr_gene()))})
  snp_subs <- reactive({
    if(("snp_subs" %in% input$which_SNPs)) {unique(filter(snp, symbol==curr_gene()))} 
    else {data.frame(matrix(nrow = 0, ncol = 0))}}) #only non-zero if corresponding checkbox is selected - but can't have "NULL" - else get "argument is of length zero" error
  snp_eve_subs <- reactive({
    if(("snp_eve_subs" %in% input$which_SNPs)) {
      snp_eve_temp <- snp_eve[which((snp_eve$symbol==curr_gene()) & (!is.na(unlist(snp_eve[,paste0("color_", input$which_eve_pvals)])))),] 
      #need the second filter criterion because otherwise will output snp names & otherwise blank if NA pvalues
      if (nrow(snp_eve_temp) > 0) {snp_eve_temp} else {data.frame(matrix(nrow = 0, ncol = 0))} #since pval_selector might remove all rows 
    } else {data.frame(matrix(nrow = 0, ncol = 0))}
  }) #only non-zero if corresponding checkbox is selected - but can't have "NULL" - else get "argument is of length zero" error
  
  snp_gabriel_subs <- reactive({
    if(("snp_gabriel_subs" %in% input$which_SNPs)) {unique(filter(snp_gabriel, symbol==curr_gene()))}
    else {data.frame(matrix(nrow = 0, ncol = 0))}}) #only non-zero if corresponding checkbox is selected - but can't have "NULL" - else get "argument is of length zero" error
  
  snp_fer_subs <- reactive({
    if(("snp_fer_subs" %in% input$which_SNPs)) {unique(filter(snp_fer, symbol==curr_gene()))}
    else {data.frame(matrix(nrow = 0, ncol = 0))}}) #only non-zero if corresponding checkbox is selected - but can't have "NULL" - else get "argument is of length zero" error
  
  snp_TAGC_subs <- reactive({
    if(("snp_TAGC_subs" %in% input$which_SNPs)) {
      snp_TAGC_temp <- snp_TAGC[which((snp_TAGC$symbol==curr_gene()) & (!is.na(unlist(snp_TAGC[,paste0("color_", input$which_TAGC_pvals)])))),]  
      #need the second filter criterion because otherwise will output snp names & otherwise blank if NA pvalues
      if (nrow(snp_TAGC_temp) > 0) {snp_TAGC_temp} else {data.frame(matrix(nrow = 0, ncol = 0))} #since pval_selector might remove all rows 
    } else {data.frame(matrix(nrow = 0, ncol = 0))}
  }) #only non-zero if corresponding checkbox is selected - but can't have "NULL" - else get "argument is of length zero" error
  
  gene_tracks <- function() {
    validate(need(curr_gene() != "", "Please enter a gene symbol or SNP ID.")) #Generate a error message when no gene id is input.
    validate(need(GeneSymbol() != FALSE, "Please enter a valid gene symbol or SNP ID.")) # Generate error message if the gene symbol is not right.
    validate(need(nrow(UserDataset_Info()) != 0, "Please choose at least one dataset.")) #Generate a error message when no data is loaded.
    
    gene_subs <- gene_subs()
    tfbs_subs <- tfbs_subs()
    snp_subs <- snp_subs()
    snp_eve_subs <- snp_eve_subs()
    snp_gabriel_subs <- snp_gabriel_subs()
    snp_fer_subs <- snp_fer_subs()
    snp_TAGC_subs <- snp_TAGC_subs()
    
    #for better visibility, increase tfbs and snp widths -- need scaling factor b/c different genes take up different amounts of space
    smallest_start <- min(gene_subs$start, tfbs_subs$start, snp_subs$start, snp_eve_subs$start, snp_gabriel_subs$start, snp_fer_subs$start, snp_TAGC_subs$start)
    largest_end <- max(gene_subs$end, tfbs_subs$end, snp_subs$end, snp_eve_subs$end, snp_gabriel_subs$end, snp_fer_subs$end, snp_TAGC_subs$end)
    scaling_factor <- (largest_end - smallest_start)/120000
    
    tfbs_subs$end <- tfbs_subs$end + 500*scaling_factor
    snp_subs$end <- snp_subs$end + 300*scaling_factor
    snp_eve_subs$end <- snp_eve_subs$end + 300*scaling_factor
    snp_gabriel_subs$end <- snp_gabriel_subs$end + 300*scaling_factor
    snp_fer_subs$end <- snp_fer_subs$end + 300*scaling_factor
    snp_TAGC_subs$end <- snp_TAGC_subs$end + 300*scaling_factor
    
    #constant for all tracks
    gen <- "hg19"
    chr <- unique(gene_subs$chromosome)
    
    #chromosome, axis and gene - these tracks show up for all genes
    #note that "col" refers to outline colors, whereas "fill" is the fill color
    bands <- chrom_bands[which(chrom_bands$chrom==chr),]
    chrom_track <- IdeogramTrack(genome = gen, bands = bands, fontcolor="black", fontsize=16) # formerly slow b/c of chromosome=chr; see https://support.bioconductor.org/p/78881/
    axis_track <- GenomeAxisTrack(col="black", fontcolor="black", fontsize=16)
    gene_track <- Gviz::GeneRegionTrack(gene_subs, genome = gen, chromosome = chr, name = "Transcripts", transcriptAnnotation="transcript", fill = "royalblue", col=NULL, grid=TRUE, col.grid="darkgrey") #add stacking="dense" if want transcript stacks combined into one
    
    #tfbs and snp tracks - only present for some genes
    
    #TFBS 
    if (nrow(tfbs_subs) > 0) {tfbs_track <- Gviz::AnnotationTrack(tfbs_subs, name="TF binding", fill = tfbs_subs$color, col=NULL, feature = tfbs_subs$score, grid=TRUE, col.grid="darkgrey")}
    
    # GRASP SNPs track
    if (nrow(snp_subs) > 0) { 
      snp_track <- Gviz::AnnotationTrack(snp_subs, name="SNPs (GRASP)", fill = snp_subs$color, col=NULL, feature=snp_subs$snp, grid=TRUE, col.grid="darkgrey")
      
      #rough estimate of number of stacks there will be in SNP track - for track scaling
      #note this stuff needs the SNPs to be ordered by position (smallest to largest)
      if (nrow(snp_subs) > 1) {
        snp_subs_temp <- snp_subs
        snp_range <- max(snp_subs_temp$start) - min(snp_subs_temp$start)
        snp_subs_temp$start_prev <- c(0, snp_subs_temp$start[1:(nrow(snp_subs_temp)-1)])
        snp_subs_temp$dist <- as.numeric(snp_subs_temp$start) - as.numeric(snp_subs_temp$start_prev)
        snp_size_init <- 0.9 + 3*as.numeric(nrow(snp_subs[which(snp_subs$dist < snp_range/10),])) + 0.3*length(unique(gene_subs$transcript))
      } else {snp_size_init <- 0.9 + 0.05*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_subs)}
    } else {snp_size_init <- 0.9 + 0.05*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_subs)}
    
    # EVE SNPs track
    if (nrow(snp_eve_subs) > 0) {
      pval_choice <- reactive({input$which_eve_pvals})  #pval_choice is responsible for dynamically coloring snps based on user selection of population
      snp_eve_track <- Gviz::AnnotationTrack(snp_eve_subs, name="SNPs (EVE)", fill = unlist(snp_eve_subs[, paste0("color_", pval_choice())]), col=NULL, feature=snp_eve_subs$snp, grid=TRUE, col.grid="darkgrey")
      
      #rough estimate of number of stacks there will be in SNP track - for track scaling
      if (nrow(snp_eve_subs) > 1) {
        snp_eve_subs_temp <- snp_eve_subs
        snp_eve_range <- max(snp_eve_subs_temp$start) - min(snp_eve_subs_temp$start)
        snp_eve_subs_temp$start_prev <- c(0, snp_eve_subs_temp$start[1:(nrow(snp_eve_subs_temp)-1)])
        snp_eve_subs_temp$dist <- as.numeric(snp_eve_subs_temp$start) - as.numeric(snp_eve_subs_temp$start_prev)
        snp_eve_size_init <- 1.5 + as.numeric(nrow(snp_eve_subs[which(snp_eve_subs$dist < snp_eve_range/10),])) + 0.3*length(unique(gene_subs$transcript))
      } else {snp_eve_size_init <- 1.4 + 0.05*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_eve_subs)}
    } else {snp_eve_size_init <- 1.4 + 0.05*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_eve_subs)}
    
    # GABRIEL SNPs track
    if (nrow(snp_gabriel_subs) > 0) {
      snp_gabriel_track <- Gviz::AnnotationTrack(snp_gabriel_subs, name="SNPs (GABRIEL)", fill = snp_gabriel_subs$color, col=NULL, feature=snp_gabriel_subs$snp, grid=TRUE, col.grid="darkgrey")
      
      #rough estimate of number of stacks there will be in SNP track - for track scaling
      if (nrow(snp_gabriel_subs) > 1) {
        snp_gabriel_subs_temp <- snp_gabriel_subs
        snp_gabriel_range <- max(snp_gabriel_subs_temp$start) - min(snp_gabriel_subs_temp$start)
        snp_gabriel_subs_temp$start_prev <- c(0, snp_gabriel_subs_temp$start[1:(nrow(snp_gabriel_subs_temp)-1)])
        snp_gabriel_subs_temp$dist <- as.numeric(snp_gabriel_subs_temp$start) - as.numeric(snp_gabriel_subs_temp$start_prev)
        snp_gabriel_size_init <- 1 + as.numeric(nrow(snp_gabriel_subs[which(snp_gabriel_subs$dist < snp_gabriel_range/10),])/4) + 0.12*length(unique(gene_subs$transcript))
      } else {snp_gabriel_size_init <- 1.4 + 0.1*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_gabriel_subs)}
    } else {snp_gabriel_size_init <- 1.4 + 0.1*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_gabriel_subs)}
    
    # Ferreira SNPs track
    if (nrow(snp_fer_subs) > 0) {
      snp_fer_track <- Gviz::AnnotationTrack(snp_fer_subs, name="SNPs (Ferreira)", fill = snp_fer_subs$color, col=NULL, feature=snp_fer_subs$snp, grid=TRUE, col.grid="darkgrey")
      
      #rough estimate of number of stacks there will be in SNP track - for track scaling
      if (nrow(snp_fer_subs) > 1) {
        snp_fer_subs_temp <- snp_fer_subs
        snp_fer_range <- max(snp_fer_subs_temp$start) - min(snp_fer_subs_temp$start)
        snp_fer_subs_temp$start_prev <- c(0, snp_fer_subs_temp$start[1:(nrow(snp_fer_subs_temp)-1)])
        snp_fer_subs_temp$dist <- as.numeric(snp_fer_subs_temp$start) - as.numeric(snp_fer_subs_temp$start_prev)
        snp_fer_size_init <- 10 + as.numeric(nrow(snp_fer_subs[which(snp_fer_subs$dist < snp_fer_range),])) + 0.12*length(unique(gene_subs$transcript))
      } else {snp_fer_size_init <- 1.4 + 0.1*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_fer_subs)}
    } else {snp_fer_size_init <- 1.4 + 0.1*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_fer_subs)}
    
    # TAGC SNPs track
    if (nrow(snp_TAGC_subs) > 0) {
      pval_choice <- reactive({input$which_TAGC_pvals})  #pval_choice is responsible for dynamically coloring snps based on user selection of population
      snp_TAGC_track <- Gviz::AnnotationTrack(snp_TAGC_subs, name="SNPs (TAGC)", fill = unlist(snp_TAGC_subs[, paste0("color_", pval_choice())]), col=NULL, feature=snp_TAGC_subs$snp, grid=TRUE, col.grid="darkgrey")
      
      #rough estimate of number of stacks there will be in SNP track - for track scaling
      if (nrow(snp_TAGC_subs) > 1) {
        snp_TAGC_subs_temp <- snp_TAGC_subs
        snp_TAGC_range <- max(snp_TAGC_subs_temp$start) - min(snp_TAGC_subs_temp$start)
        snp_TAGC_subs_temp$start_prev <- c(0, snp_TAGC_subs_temp$start[1:(nrow(snp_TAGC_subs_temp)-1)])
        snp_TAGC_subs_temp$dist <- as.numeric(snp_TAGC_subs_temp$start) - as.numeric(snp_TAGC_subs_temp$start_prev)
        snp_TAGC_size_init <- 1.5 + as.numeric(nrow(snp_TAGC_subs[which(snp_TAGC_subs$dist < snp_TAGC_range/10),])) + 0.3*length(unique(gene_subs$transcript))
      } else {snp_TAGC_size_init <- 1.4 + 0.05*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_TAGC_subs)}
    } else {snp_TAGC_size_init <- 1.4 + 0.05*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_TAGC_subs)}
    
    #track sizes - defaults throw off scaling as more tracks are added
    chrom_size <- 1.2 + 0.01*length(unique(gene_subs$transcript)) + 0.01*nrow(snp_subs) + 0.005*nrow(snp_eve_subs) + 0.01*nrow(snp_gabriel_subs)
    axis_size <- 1 + 0.05*length(unique(gene_subs$transcript)) + 0.01*nrow(snp_subs) + 0.005*nrow(snp_eve_subs) + 0.01*nrow(snp_gabriel_subs)
    gene_size <- 2 + 0.6*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_subs) + 0.05*nrow(snp_eve_subs) + 0.015*nrow(snp_gabriel_subs)
    tfbs_size <- 2 + 0.075*length(unique(gene_subs$transcript)) + 0.015*nrow(snp_subs) + 0.05*nrow(snp_eve_subs) + 0.015*nrow(snp_gabriel_subs)
    snp_size <- snp_size_init #from above
    snp_eve_size <- snp_eve_size_init #from above
    snp_gabriel_size <- snp_gabriel_size_init #from above
    snp_fer_size <- snp_fer_size_init #from above
    snp_TAGC_size <- snp_TAGC_size_init #from above
    
    #select the non-empty tracks to output -- output depends on whether there are TFBS and/or SNPs for a given gene
    subset_size <- sapply(c("tfbs_subs", "snp_subs", "snp_eve_subs", "snp_gabriel_subs", "snp_fer_subs", "snp_TAGC_subs"), function(x) {nrow(get(x))}) #size of each subset
    non_zeros <- names(subset_size)[which(!(subset_size==0))] #which subsets have non-zero size
    
    df_extract <- function(x,y) { #gives name of track and track size variable for non-zero subsets (y is "track" or "size")
      if (length(non_zeros) > 0) {
        get(paste0(strsplit(x, 'subs'),y)) #trim off "subs" and append either "track" or "size"
      } else {NULL} #to avoid meltdown if no subsets were non-zero
    }
    
    #use df_extract function to get track & track size corresponding to all non-zero subsets
    #note chrom_track, axis_track and gene_track are present for all
    selected_tracks <- list(chrom_track, axis_track, gene_track, 
                            sapply(non_zeros, df_extract, y="track")$tfbs_subs, 
                            sapply(non_zeros, df_extract, y="track")$snp_subs, 
                            sapply(non_zeros, df_extract, y="track")$snp_eve_subs, 
                            sapply(non_zeros, df_extract, y="track")$snp_gabriel_subs, 
                            sapply(non_zeros, df_extract, y="track")$snp_fer_subs, 
                            sapply(non_zeros, df_extract, y="track")$snp_TAGC_subs)
    
    selected_tracks <- Filter(Negate(function(x) is.null(unlist(x))), selected_tracks) #remove null elements from list
    
    selected_sizes <- na.omit(c(chrom_size,axis_size,gene_size,
                                sapply(non_zeros, df_extract, y="size")[1], 
                                sapply(non_zeros, df_extract, y="size")[2], 
                                sapply(non_zeros, df_extract, y="size")[3], 
                                sapply(non_zeros, df_extract, y="size")[4], 
                                sapply(non_zeros, df_extract, y="size")[5],
                                sapply(non_zeros, df_extract, y="size")[6]))
    
    selected_sizes <- Filter(Negate(function(x) is.null(unlist(x))), selected_sizes) #remove null elements from list - else run into trouble in conditions when no TFBS & no SNP tracks selected
    #note: use names to extract from selected_tracks b/c it is a list vs. index to extract from selected_sizes, since this is numeric
    
    #plot tracks 
    plotTracks(selected_tracks, sizes=selected_sizes, background.panel = "#BDB6B0", background.title = "firebrick4", col.border.title = "firebrick4", groupAnnotation = "feature", fontcolor.group = "darkblue", cex.group=0.75, just.group="below", cex.title=1.1)
    
  }
  
  #plot height increases if more tracks are displayed
  observe({output$gene_tracks_outp2 <- renderPlot({gene_tracks()}, width=1055,
                                                  height=400 + 15*length(unique(gene_subs()$transcript)) + 30*nrow(snp_eve_subs()) + 10*(nrow(snp_subs())+nrow(snp_gabriel_subs())+nrow(snp_fer_subs())+nrow(snp_TAGC_subs())))})
  
  #################################
  ## SNP data table for download ##
  #################################
  snp_subs_temp <- reactive({
    if (nrow(snp_subs()) > 0) {
      snp_subs()%>%
        dplyr::rename(position=start, meta_P=p) %>%
        dplyr::mutate(source = "GRASP") %>%
        dplyr::select(chromosome, snp, symbol, position, pmid, source, meta_P)
    }
  })
  
  snp_eve_subs_temp <- reactive({
    if (nrow(snp_eve_subs()) > 0) {
      snp_eve_subs() %>%
        dplyr::rename(position=start) %>%
        dplyr::mutate(source = "EVE") %>%
        dplyr::select(-c(end, color_meta_P, color_meta_P_EA, color_meta_P_AA, color_meta_P_LAT))
    }
  })
  
  snp_gabriel_subs_temp <- reactive({
    if (nrow(snp_gabriel_subs()) > 0) {
      snp_gabriel_subs() %>%
        dplyr::rename(position=start, meta_P=P_ran) %>%
        dplyr::mutate(source = "GABRIEL") %>%
        dplyr::select(-c(end, color))
    }
  })
  
  snp_fer_subs_temp <- reactive({
    if (nrow(snp_fer_subs()) > 0) {
      snp_fer_subs() %>%
        dplyr::rename(position=start, meta_P=PVALUE) %>%
        dplyr::mutate(source = "Ferreira") %>%
        dplyr::select(-c(end, color))
    }
  })
  
  snp_TAGC_subs_temp <- reactive({
    if (nrow(snp_TAGC_subs()) > 0) {
      snp_TAGC_subs() %>%
        dplyr::rename(position=start) %>%
        dplyr::mutate(source = "TAGC") %>%
        dplyr::select(-c(end, color_p_ran_multi, color_p_ran_euro))
    }
  }) 
  
  snp_data <- reactive({dplyr::bind_rows(snp_subs_temp(), snp_eve_subs_temp(), snp_gabriel_subs_temp(), snp_fer_subs_temp(), snp_TAGC_subs_temp())})
  
  ######################
  ## Download buttons ##
  ######################
  
  graphgene=reactive({curr_gene()})
  
  output$asthma_fc_download <- downloadHandler(
    filename= function(){paste0("REALGAR_asthma_forestplot_", graphgene(), ".png")},
    content=function(file){
      png(file, width=15, height=12, units="in", res=300)
      print(forestplot_func(data3_Asthma(),"Asthma Transcriptomic Results for ",curr_gene()))
      dev.off()})
  
  output$GC_fc_download <- downloadHandler(
    filename= function(){paste0("REALGAR_treatment_forestplot_", graphgene(), ".png")},
    content=function(file){
      png(file, width=15, height=12, units="in", res=300)
      print(forestplot_func(data3_GC(),"Exposure Transcriptomic Results for ",curr_gene()))
      dev.off()})
  
  output$gene_tracks_download <- downloadHandler(
      filename= function(){paste0("REALGAR_gene_tracks_", graphgene(), ".png")},
      content=function(file){
          png(file, width=16, height=12, units="in", res=300)
          gene_tracks()
          dev.off()})
  
  output$table_download <- downloadHandler(filename = function() {paste0('REALGAR_expression_summary_table_',graphgene(), '.csv')},
                                           content = function(file) {write.csv(rbind(tableforgraph_Asthma(), tableforgraph_GC()), file, row.names=FALSE)})
  
  output$SNP_data_download <- downloadHandler(filename = function() {paste0('REALGAR_SNP_results_',graphgene(), '.csv')},
                                              content = function(file) {write.csv(snp_data(), file, row.names=FALSE)})
})
